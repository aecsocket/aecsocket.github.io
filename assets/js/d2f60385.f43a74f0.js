"use strict";(self.webpackChunkaecsocket_github_io=self.webpackChunkaecsocket_github_io||[]).push([[785],{3905:(e,t,i)=>{i.d(t,{Zo:()=>p,kt:()=>m});var n=i(7294);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var i=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(i),u=a,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||o;return i?n.createElement(m,r(r({ref:t},p),{},{components:i})):n.createElement(m,r({ref:t},p))}));function m(e,t){var i=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=i.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=i[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}u.displayName="MDXCreateElement"},346:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=i(7462),a=(i(7294),i(3905));const o={sidebar_position:1},r="Architecture",s={unversionedId:"rattle/guide/architecture",id:"rattle/guide/architecture",title:"Architecture",description:"An explanation of the concepts and design of the project.",source:"@site/docs/rattle/guide/architecture.md",sourceDirName:"rattle/guide",slug:"/rattle/guide/architecture",permalink:"/rattle/guide/architecture",draft:!1,editUrl:"https://github.com/aecsocket/aecsocket.github.io/blob/main/docs/rattle/guide/architecture.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"sidebar",previous:{title:"Guide",permalink:"/rattle/guide/"},next:{title:"User guide",permalink:"/rattle/guide/user/"}},l={},c=[{value:"Physics engine",id:"physics-engine",level:2},{value:"Geometry",id:"geometry",level:2},{value:"Shape",id:"shape",level:2},{value:"Physics space",id:"physics-space",level:2},{value:"Collider",id:"collider",level:2},{value:"Rigid body",id:"rigid-body",level:2},{value:"Joint",id:"joint",level:2},{value:"Impulse joints",id:"impulse-joints",level:3},{value:"Multibody joints",id:"multibody-joints",level:3},{value:"World physics",id:"world-physics",level:2},{value:"Terrain strategy",id:"terrain-strategy",level:3},{value:"Entity strategy",id:"entity-strategy",level:3}],p={toc:c},h="wrapper";function d(e){let{components:t,...i}=e;return(0,a.kt)(h,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"architecture"},"Architecture"),(0,a.kt)("p",null,"An explanation of the concepts and design of the project."),(0,a.kt)("p",null,"Here is a brief overview of the terminology and concepts used in the project - if you need more\ndetailed explanations on the various concepts, see the code documentation."),(0,a.kt)("h2",{id:"physics-engine"},"Physics engine"),(0,a.kt)("p",null,'Rattle is simply a frontend, or wrapper, around an existing physics engine - this engine is called\nthe "backend". The current backend and technologies used are:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rattle-api")," - the frontend exposed to developers for communicating with a physics engine"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://rapier.rs"},"Rapier")," - a physics engine written in Rust"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/aecsocket/rapier-ffi/tree/main/rapier-ffi"},"rapier-ffi/rapier-ffi")," - C bindings for the Rust engine"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/aecsocket/rapier-ffi/tree/main/rapier-java"},"rapier-ffi/rapier-java")," - Java bindings for the C bindings"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rattle-rapier")," - the implementation of ",(0,a.kt)("inlineCode",{parentName:"li"},"rattle-api")," for the Rapier engine"),(0,a.kt)("li",{parentName:"ul"},"The platform implementations of Rattle, e.g. ",(0,a.kt)("inlineCode",{parentName:"li"},"rattle-paper"))),(0,a.kt)("p",null,'Since the backend is not written in Java, it is referred to as a "native library" - as in, it is\nmanaged by the native operating system, not the JVM (Java).'),(0,a.kt)("p",null,"The engine's job is to create and manage resources that are required by the native libraries, such\nas physics spaces and rigid bodies."),(0,a.kt)("h2",{id:"geometry"},"Geometry"),(0,a.kt)("p",null,"A geometry is a raw, user-created version of a shape with volume in the world. Some examples of\ngeometries are spheres or boxes. Geometries do not store any info on where they are in the world;\nthey only store local data. By itself, a geometry cannot be used for physics simulations, however\ncan be baked into a ",(0,a.kt)("em",{parentName:"p"},"shape"),"."),(0,a.kt)("h2",{id:"shape"},"Shape"),(0,a.kt)("p",null,"A shape is a baked (converted) form of a ",(0,a.kt)("em",{parentName:"p"},"geometry")," which can be used for physics. You can ",(0,a.kt)("strong",{parentName:"p"},"not"),"\nget a geometry back from a shape. These also do not store info on where they are in the world,\nand may be somewhat expensive to compute (e.g. if doing a more complex operation like making a\nconvex hull or convex decomposition). So it is best to cache these and reuse them as much as\npossible."),(0,a.kt)("h2",{id:"physics-space"},"Physics space"),(0,a.kt)("p",null,"All physics simulation happens inside of a physics space. There can be multiple physics spaces\nactive at once, but they cannot share any physics state like ",(0,a.kt)("em",{parentName:"p"},"rigid bodies")," (data is OK though,\nlike ",(0,a.kt)("em",{parentName:"p"},"shapes"),")."),(0,a.kt)("h2",{id:"collider"},"Collider"),(0,a.kt)("p",null,"A collider is an object owned by a physics space which has a ",(0,a.kt)("em",{parentName:"p"},"shape")," and position in the world,\nand allows other colliders to be affected by it - this means it can push them away via forces\nand impulses, the typical classical mechanics effects. However, a collider cannot move by itself -\nit has no concept of a velocity (linear or angular). Instead, this is done by ",(0,a.kt)("em",{parentName:"p"},"rigid bodies"),"."),(0,a.kt)("h2",{id:"rigid-body"},"Rigid body"),(0,a.kt)("p",null,"A rigid body is an object that simulates Newtonian dynamics such as velocity, forces, and impulses.\nAlthough a collider may apply forces to other objects, a rigid body is the object that actually\nuses those forces to be pushed away, spun, etc. Zero or more colliders may be attached to a rigid\nbody, in which case the collider effectively follows the body as it moves.\nRigid bodies may be:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"fixed - the body does not move by itself"),(0,a.kt)("li",{parentName:"ul"},"dynamic - the physics engine simulates forces and dynamics for themselves"),(0,a.kt)("li",{parentName:"ul"},"kinematic - the user defines what position the body moves to, and the engine calculates the\nvelocities for that")),(0,a.kt)("p",null,"A rigid body may also have continuous collision detection enabled (CCD) to make collision detection\nmore precise when the body is moving quickly (due to tunneling). At a glance, this does a\ncontinuous sweep to test for collisions between a body's old and current position, and if so,\nmoves it back to that first hit."),(0,a.kt)("h2",{id:"joint"},"Joint"),(0,a.kt)("p",null,'A joint is a constraint that can be applied by a user to a physics space, which ensures that two\nrigid bodies keep some sort of positional relationship to each other - it ensures that the\nconstraint is "solved". For example, a door may be modelled by a joint which locks the translation\nof a body (not allowing it to move), but keeps a single "hinge" axis free for rotation\n(allowing it to swing, but only on one axis). Limits could further be applied to these axis to\nallow it to only swing a certain amount.'),(0,a.kt)("h3",{id:"impulse-joints"},"Impulse joints"),(0,a.kt)("p",null,"An impulse joint applies impulses to try to solve its constraint. This means that they\nare fast to compute, and they are flexible, allowing loops in the graph of all joints in the space.\nHowever, they do not resolve constraints perfectly - there is often error in the position.\nThis is fine for most applications, but not all."),(0,a.kt)("h3",{id:"multibody-joints"},"Multibody joints"),(0,a.kt)("p",null,"A multibody joint works in reduced coordinates, forming a tree of multibodies in the physics space\nwhich resolve their positions all at once. This means that they work slower, however are\nguaranteed to perfectly resolve constraints (as long as the constraints themselves are valid)."),(0,a.kt)("h2",{id:"world-physics"},"World physics"),(0,a.kt)("p",null,"When working with a server environment, each world loaded in the game will have up to one\nphysics space assigned to it. This handles all physics for this world, and can be manipulated\nusing commands and through the API."),(0,a.kt)("p",null,"Developer note: this is one of the most crucial parts of the API, however there are some safety\nguarantees you must uphold when working with one! See the corresponding classes in the code for more documentation."),(0,a.kt)("h3",{id:"terrain-strategy"},"Terrain strategy"),(0,a.kt)("p",null,'To allow blocks in the world to be collidable, we use a terrain strategy. The current terrain\nstrategy is a "dynamic terrain" implementation, which creates collision on-the-fly as bodies\nenter or exit chunks in the world.'),(0,a.kt)("h3",{id:"entity-strategy"},"Entity strategy"),(0,a.kt)("p",null,"To allow entities in the world to be collidable, we use an entity strategy. The default\nimplementation simply assigns a rigid body to entities, and moves the body around as the entity\nalso moves."))}d.isMDXComponent=!0}}]);